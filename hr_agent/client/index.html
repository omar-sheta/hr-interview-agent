<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HR Interview Agent - Client Server</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #1e293b 0%, #1e40af 50%, #1e293b 100%);
        }
        .loading-spinner {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .progress-bar {
            transition: width 0.3s ease;
        }
        .mic-level {
            transition: width 0.1s ease;
        }
        .recording-pulse {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .sortable-drag {
            opacity: 0.8 !important;
        }
        .sortable-ghost {
            opacity: 0.4 !important;
        }
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="min-h-screen bg-gray-100 text-gray-800">
    <!-- Header matching original design -->
    <header class="gradient-bg text-white p-6 shadow-2xl">
        <div class="max-w-7xl mx-auto flex items-center justify-between">
            <!-- Left Logo -->
            <div class="flex items-center">
                <div class="bg-white rounded-2xl p-4 shadow-lg hover:shadow-xl transition-shadow duration-300">
                    <img 
                        src="images/HIVE-logo-4-color.png" 
                        alt="HIVE Logo" 
                        class="h-28 md:h-36 w-auto object-contain"
                        onerror="this.src='images/logo-hive.svg'"
                    />
                </div>
            </div>
            
            <!-- Center Title -->
            <div class="text-center flex-1 mx-8">
                <h1 class="text-2xl md:text-4xl font-bold bg-gradient-to-r from-blue-200 to-white bg-clip-text text-transparent">
                    HR Interview Agent
                </h1>
                <p class="text-blue-200 text-sm md:text-base mt-2 font-medium">
                    üöÄ AI-Powered Interview Assistant - Client-Server Architecture
                </p>
                <div class="flex justify-center items-center gap-2 mt-2">
                    <div id="server-indicator" class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
                    <span id="server-status" class="text-xs text-green-300">Checking Server...</span>
                </div>
                <div class="text-center mt-1">
                    <span id="api-info" class="text-xs text-blue-200 opacity-75">API: Loading...</span>
                    <span id="llm-status" class="ml-3 text-xs text-yellow-200">LLM: Loading...</span>
                </div>
            </div>
            
            <!-- Right Logo -->
            <div class="flex items-center">
                <div class="bg-white rounded-2xl p-4 shadow-lg hover:shadow-xl transition-shadow duration-300">
                    <img 
                        src="images/gea.png" 
                        alt="GE Appliances Logo" 
                        class="h-28 md:h-36 w-56 object-contain"
                        onerror="this.src='images/logo-gea.svg'"
                    />
                </div>
            </div>
        </div>
    </header>

    <main class="p-8">
        <!-- Setup Interview Section -->
        <div id="setup-section" class="max-w-2xl mx-auto bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4">Setup Interview</h2>
            
            <!-- Mic & TTS Status -->
            <div class="flex items-center gap-2 mb-3 text-sm">
                <span id="mic-status" class="inline-flex items-center px-2 py-1 rounded bg-yellow-100 text-yellow-800">
                    Mic access needed
                </span>
                <button onclick="ensureMicPermission()" class="px-2 py-1 rounded bg-gray-100 text-gray-800 hover:bg-gray-200">Test microphone</button>
            </div>
            <div id="mic-error" class="mb-3 p-3 rounded border border-red-200 bg-red-50 text-red-800 text-sm" style="display: none;"></div>
            
            <div class="flex items-center gap-2 mb-3 text-sm">
                <span id="tts-status" class="inline-flex items-center px-2 py-1 rounded bg-yellow-100 text-yellow-800">
                    Voice will preload
                </span>
            </div>

            <div class="mb-3 text-sm">
                <span id="recorder-status" class="inline-flex items-center px-2 py-1 rounded bg-blue-100 text-blue-800">
                    Checking recording support...
                </span>
                <div id="recorder-warning" class="hidden mt-2 p-3 rounded border border-yellow-200 bg-yellow-50 text-yellow-800">
                    Live recording may be unavailable on this device. You can always upload an audio file below.
                </div>
            </div>

            <input
                type="text"
                id="candidate-name"
                class="w-full p-2 border rounded mb-4"
                placeholder="Candidate name (optional)"
            />
            
            <!-- Job Description Input -->
            <input
                type="text"
                id="job-role-input"
                class="w-full p-2 border rounded mb-4"
                placeholder="Job title (optional, e.g., Senior Python Developer)"
            />

            <textarea
                id="job-description"
                class="w-full p-2 border rounded mb-4"
                rows="10"
                placeholder="Paste job description here..."
            ></textarea>
            
            <!-- Number of Questions -->
            <div class="flex items-center mb-4">
                <label class="mr-2">Number of Questions:</label>
                <input
                    type="number"
                    id="num-questions"
                    class="p-2 border rounded w-24"
                    value="5"
                    min="1"
                    max="10"
                />
            </div>
            
            <!-- Generate Questions Button -->
            <button
                id="generate-btn"
                onclick="handleGenerateQuestions()"
                class="group relative py-4 px-8 rounded-xl font-bold shadow-lg transform transition-all duration-200 bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white hover:shadow-purple-500/25 hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:text-gray-700 disabled:shadow-none disabled:transform-none"
            >
                <span class="flex items-center gap-3">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
                    </svg>
                    Generate Questions
                </span>
            </button>
            
            <!-- Loading Message -->
            <div id="loading-message" class="mt-4 p-4 bg-blue-50 border border-blue-200 rounded" style="display: none;">
                <div class="flex items-center">
                    <div class="loading-spinner rounded-full h-6 w-6 border-b-2 border-blue-600 mr-3"></div>
                    <p class="text-blue-800" id="loading-text">Generating questions with AI...</p>
                </div>
            </div>
            

            
            <!-- Generated Questions Display -->
            <div id="generated-questions" class="mt-6" style="display: none;">
                <h3 class="font-semibold text-lg mb-3">Generated Questions:</h3>
                <div id="questions-list" class="space-y-3"></div>
                <button
                    onclick="showQuestionReview()"
                    class="py-2 px-4 rounded font-bold mt-4 bg-green-500 hover:bg-green-700 text-white"
                >
                    Review & Approve Questions
                </button>
            </div>
        </div>

        <!-- Question Review Section -->
        <div id="review-section" class="max-w-5xl mx-auto bg-gray-50 p-8 rounded-xl shadow-lg" style="display: none;">
            <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6 mb-6">
                <h2 class="text-3xl font-bold text-gray-900 mb-3 flex items-center gap-3">
                    üìù Review & Approve Questions
                </h2>
                <p class="text-gray-600 mb-4">Review each question below. You can drag to reorder, edit with AI, and select which ones to use.</p>
                
                <div class="flex items-center gap-4 text-sm">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 bg-green-500 rounded-full"></div>
                        <span class="approval-count font-medium text-gray-700">0 of 0 questions approved</span>
                    </div>
                    <div class="flex items-center gap-2 text-gray-500">
                        <span>üí° Tip: Drag ‚ãÆ‚ãÆ to reorder, click ‚úèÔ∏è to edit</span>
                    </div>
                </div>
            </div>
            
            <div id="review-questions-list" class="space-y-3"></div>
            
            <!-- Review Action Buttons -->
            <div class="flex justify-between items-center mt-8 pt-6 border-t border-gray-200">
                <div class="flex items-center gap-4">
                    <div id="approval-count" class="text-sm text-gray-600 font-medium">
                        0 of 0 questions approved
                    </div>
                </div>
                <div class="flex gap-4">
                    <button
                        onclick="selectAllQuestions()"
                        class="group relative px-6 py-3 bg-gradient-to-r from-emerald-500 to-green-600 hover:from-emerald-600 hover:to-green-700 text-white font-semibold rounded-xl shadow-lg hover:shadow-emerald-500/25 transform hover:scale-105 transition-all duration-200"
                    >
                        Select All Questions
                    </button>
                    
                    <button
                        onclick="clearAllQuestions()"
                        class="group relative px-6 py-3 bg-gradient-to-r from-red-500 to-pink-600 hover:from-red-600 hover:to-pink-700 text-white font-semibold rounded-xl shadow-lg hover:shadow-red-500/25 transform hover:scale-105 transition-all duration-200"
                    >
                        Clear All
                    </button>
                    
                    <button
                        onclick="goBackToSetup()"
                        class="group relative px-6 py-3 bg-gradient-to-r from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 text-white font-semibold rounded-xl shadow-lg hover:shadow-gray-500/25 transform hover:scale-105 transition-all duration-200"
                    >
                        Back to Setup
                    </button>
                    
                    <button
                        id="approve-btn"
                        onclick="approveAndStartInterview()"
                        class="group relative px-8 py-4 font-bold rounded-xl shadow-lg transform transition-all duration-200 bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white hover:shadow-blue-500/25 hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:text-gray-700 disabled:shadow-none disabled:transform-none"
                        disabled
                    >
                        <span class="flex items-center gap-3">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                            Approve & Start Interview
                        </span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Interview In Progress Section -->
        <div id="interview-section" class="hidden w-full max-w-4xl mx-auto">
            <!-- Mic troubleshooting banner -->
            <div id="mic-warning" class="mb-4 p-3 rounded-lg border border-yellow-300 bg-yellow-50" style="display: none;">
                <div class="flex items-center justify-between gap-3">
                    <div class="text-sm text-yellow-800" id="mic-warning-text">
                        Please grant microphone access before recording.
                    </div>
                    <button onclick="ensureMicPermission()" class="px-3 py-1 rounded bg-yellow-200 hover:bg-yellow-300 text-yellow-900 text-sm font-medium">Grant Access</button>
                </div>
            </div>

            <div id="recording-alert" class="mb-4 p-3 rounded-lg border bg-yellow-50 text-sm text-yellow-800 hidden">
                <span id="recording-alert-text">Recording notice</span>
            </div>
            
            <div class="text-center mb-6">
                <h2 id="question-title" class="text-2xl font-semibold text-gray-800 mb-2">
                    Question 1
                </h2>
                <div class="w-full bg-gray-200 rounded-full h-2 mb-4">
                    <div id="progress-bar" class="bg-blue-600 h-2 rounded-full progress-bar" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="bg-white p-8 rounded-lg shadow-lg border border-gray-200">
                <p id="current-question-text" class="text-2xl font-semibold text-gray-800 mb-6 text-center">
                    Loading question...
                </p>
                
                <div class="flex justify-center items-center space-x-4 mb-6">
                    <button
                        id="play-question-btn"
                        onclick="playCurrentQuestion()"
                        class="px-4 py-2 rounded-full font-semibold text-white transition-colors flex items-center gap-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-500 disabled:cursor-not-allowed"
                        disabled
                    >
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832L14 10.202a1 1 0 000-1.65l-4.445-2.384z" clip-rule="evenodd" />
                        </svg>
                        <span id="play-btn-text">Play Question</span>
                    </button>
                </div>

                <!-- Transcription Result Display -->
                <div id="transcription-display" class="mb-6 p-4 rounded bg-green-50 border border-green-200" style="display: none;">
                    <div class="flex items-start gap-3">
                        <svg class="w-5 h-5 text-green-600 mt-1 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                        </svg>
                        <div>
                            <h4 class="text-sm font-semibold text-green-800 mb-1">Your Response:</h4>
                            <p id="transcription-text" class="text-green-700 italic leading-relaxed"></p>
                        </div>
                    </div>
                </div>

                <div id="post-response-actions" class="flex flex-wrap gap-3 justify-center mb-6 hidden">
                    <button
                        id="redo-question-btn"
                        onclick="redoCurrentQuestion()"
                        class="px-4 py-2 rounded bg-yellow-200 hover:bg-yellow-300 text-yellow-900 font-semibold"
                    >
                        Redo Question
                    </button>
                    <button
                        id="next-question-btn"
                        onclick="continueToNextQuestion()"
                        class="px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white font-semibold"
                    >
                        Continue to Next Question
                    </button>
                </div>

                <div class="border-t pt-6">
                    <!-- Mic Level Display -->
                    <div class="flex items-center justify-between mb-3">
                        <span class="text-sm text-gray-600">Mic level</span>
                        <div class="w-40 h-2 bg-gray-200 rounded">
                            <div id="mic-level" class="h-2 bg-green-500 rounded mic-level" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <!-- Recording Controls -->
                    <div class="flex gap-3 mb-4">
                        <button 
                            id="start-recording-btn"
                            onclick="startRecording()" 
                            class="px-4 py-2 rounded text-white font-semibold bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                        >
                            Start Recording
                        </button>
                        <button 
                            id="stop-recording-btn"
                            onclick="stopRecording()" 
                            class="px-4 py-2 rounded bg-red-600 hover:bg-red-700 text-white font-semibold"
                            style="display: none;"
                        >
                            Stop Recording
                        </button>
                        <button
                            id="skip-question-btn"
                            onclick="skipQuestion()"
                            class="px-4 py-2 rounded bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold"
                        >
                            Skip Question
                        </button>
                    </div>
                    
                    <!-- File Upload Alternative -->
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                        Upload your response (audio file):
                    </label>
                    <input 
                        type="file" 
                        id="audio-upload"
                        accept="audio/*,.m4a,.wav,.mp3,.mp4,.webm" 
                        onchange="handleAudioUpload(event)"
                        class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                    />
                    <p class="text-xs text-gray-500 mt-2">
                        Accepted formats: MP3, WAV, M4A, etc.
                    </p>
                </div>
            </div>
        </div>

        <!-- Interview Completed Section -->
        <div id="completion-section" class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md" style="display: none;">
            <div class="text-center mb-8">
                <h2 class="text-3xl font-bold text-green-600 mb-2">Interview Completed!</h2>
                <p class="text-gray-600">Thank you for completing the interview. Here's a summary of your responses:</p>
            </div>

            <div id="interview-results" class="space-y-6"></div>

            <!-- Action Buttons -->
            <div class="flex justify-center gap-4 pt-6 border-t">
                <button 
                    onclick="startNewInterview()"
                    class="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors"
                >
                    Start New Interview
                </button>
                <button 
                    onclick="downloadResults()"
                    class="px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg transition-colors"
                >
                    Download Results
                </button>
            </div>
        </div>

        <!-- Edit Question Modal -->
        <div id="edit-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-auto">
                <div class="p-6">
                    <div class="flex items-center justify-between mb-6">
                        <h3 class="text-2xl font-bold text-gray-900">‚ú® Edit Question with AI</h3>
                        <button onclick="closeEditModal()" class="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
                    </div>
                    
                    <div class="mb-6">
                        <label class="block text-sm font-semibold text-gray-700 mb-2">Original Question:</label>
                        <div id="edit-question-text" class="bg-gray-50 border border-gray-200 p-4 rounded-lg text-gray-800 leading-relaxed"></div>
                    </div>
                    
                    <div class="mb-6">
                        <label for="edit-instruction" class="block text-sm font-semibold text-gray-700 mb-2">How would you like to modify this question?</label>
                        <input type="text" id="edit-instruction" 
                               class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors" 
                               placeholder="e.g., 'Make it more technical', 'Focus on leadership skills', 'Add specific examples'">
                        <p class="text-xs text-gray-500 mt-1">Be specific about what changes you want to see</p>
                    </div>
                    
                    <div class="flex justify-end space-x-3">
                        <button onclick="closeEditModal()" 
                                class="px-6 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors font-medium">
                            Cancel
                        </button>
                        <button id="submit-edit-btn" onclick="submitEditedQuestion()" 
                                class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium flex items-center gap-2">
                            <span>‚ú® Apply Changes</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Dynamically determine the correct API base URL
        const currentHost = window.location.hostname;
        const currentProtocol = window.location.protocol;
        const isSecure = currentProtocol === 'https:';

        // Allow overriding the API host/port via query parameters
        const urlParams = new URLSearchParams(window.location.search);
        const customApiHost = urlParams.get('api_host') || currentHost;
        const customApiPort = urlParams.get('api_port');

        // Determine which port to use (allow explicit override)
        let apiPort = customApiPort || (isSecure ? '8002' : '8001');

        // Build the primary API URL (match the current page protocol by default)
        let API_BASE = `${currentProtocol}//${customApiHost}:${apiPort}`;

        // Prepare HTTP fallback when browsing over HTTPS (unless user forced a port)
        let FALLBACK_API_BASE = null;
        if (isSecure && !customApiPort) {
            FALLBACK_API_BASE = `http://${customApiHost}:8001`;
        }

        console.log('API Configuration:');
        console.log('  Protocol:', currentProtocol);
        console.log('  Host:', customApiHost);
        console.log('  Port:', apiPort);
        console.log('  Primary API:', API_BASE);
        if (FALLBACK_API_BASE) {
            console.log('  Fallback API:', FALLBACK_API_BASE);
        }

        const getApiHostDisplay = () => {
            try {
                return new URL(API_BASE).host;
            } catch {
                return API_BASE;
            }
        };
        
        // Helper function to make API requests with automatic fallback
        async function makeAPIRequest(endpoint, options = {}) {
            const buildUrl = (base, path) => {
                try {
                    return new URL(path, base).toString();
                } catch (err) {
                    console.warn('Falling back to manual URL concatenation:', err);
                    return `${base.replace(/\/+$/, '')}${path}`;
                }
            };

            const urls = [];
            if (API_BASE) {
                urls.push(buildUrl(API_BASE, endpoint));
            }
            if (FALLBACK_API_BASE) {
                urls.push(buildUrl(FALLBACK_API_BASE, endpoint));
            }

            for (let i = 0; i < urls.length; i++) {
                const url = urls[i];
                const isLastAttempt = i === urls.length - 1;

                try {
                    console.log(`Attempting API request to: ${url}`);
                    const response = await fetch(url, {
                        ...options,
                        signal: AbortSignal.timeout(10000) // 10 second timeout
                    });

                    if (response.ok) {
                        console.log(`‚úÖ API request successful: ${url}`);

                        const resolved = new URL(url);
                        const newBase = resolved.origin;
                        if (API_BASE !== newBase) {
                            API_BASE = newBase;
                            console.log(`Updated API_BASE to working URL: ${API_BASE}`);
                        }

                        // If the fallback succeeded, avoid retrying the failing primary on future requests
                        if (i > 0) {
                            FALLBACK_API_BASE = null;
                        }

                        return response;
                    }

                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                } catch (error) {
                    console.warn(`‚ùå API request failed for ${url}:`, error.message);
                    if (isLastAttempt) {
                        throw error;
                    }
                }
            }
        }
        const MEDIA_RECORDER_PREFERENCES = [
            { type: 'audio/webm;codecs=opus', extension: 'webm' },
            { type: 'audio/webm', extension: 'webm' },
            { type: 'audio/ogg;codecs=opus', extension: 'ogg' },
            { type: 'audio/ogg', extension: 'ogg' },
            { type: 'audio/mp4;codecs=mp4a.40.2', extension: 'm4a' },
            { type: 'audio/mp4', extension: 'm4a' },
            { type: 'audio/mpeg', extension: 'mp3' },
            { type: 'audio/x-m4a', extension: 'm4a' }
        ];
        const USER_AGENT = navigator.userAgent || '';
        const IS_SAFARI = /Safari/i.test(USER_AGENT) && !/Chrome/i.test(USER_AGENT);
        const IS_SECURE_CONTEXT = Boolean(window.isSecureContext);
        const SILENCE_THRESHOLD = 0.01; // RMS level considered silent (more sensitive)
        const SILENCE_DURATION_MS = 5000; // 5 seconds of silence after speaking starts
        const NOISE_RMS_THRESHOLD = 0.3; // RMS level considered noisy (more sensitive)
        const NOISE_ZCR_THRESHOLD = 0.5; // High zero-crossing rate indicates noise (more sensitive)
        const NOISE_DURATION_MS = 5000; // 5 seconds of noise after speaking starts

        // Application State
        let appState = {
            currentScreen: 'setup', // setup, questions_generated, questions_approved, in_progress, completed
            micPermission: false,
            isRecording: false,
            mediaRecorder: null,
            audioChunks: [],
            recordedBlob: null,
            currentQuestionIndex: 0,
            questions: [],
            approvedQuestions: [],
            sessionId: null,
            responses: [],
            jobDescription: '',
            jobRole: '',
            candidateName: '',
            numQuestions: 5,
            audioContext: null,
            audioResumeHandlerAttached: false,
            micStream: null,
            questionAudio: null,
            isPlayingQuestion: false,
            questionSource: 'ollama',
            usedFallback: false,
            fallbackReason: '',
            silenceStart: null,
            noiseStart: null,
            pendingResponse: null,
            autoStopReason: null,
            recorderSupported: typeof MediaRecorder !== 'undefined',
            recordingMimeType: '',
            recordingExtension: 'webm',
            speakingDetected: false, // Track if user has started speaking
            speakingStartTime: null // When speaking was first detected
        };

        // Initialize app on page load
        window.onload = function() {
            checkServerHealth();
            initializeApp();
            
            // Debug: Test button functionality
            console.log('Page loaded. Testing button bindings...');
            
            // Expose functions globally for debugging
            window.debugFunctions = {
                selectAllQuestions,
                clearAllQuestions,
                updateApprovalCount,
                approveAndStartInterview,
                goBackToSetup
            };
        };

        function initializeApp() {
            // Set default job description
            document.getElementById('job-description').value = "Seeking a skilled factory worker or engineer to join our team at GE Appliances. The ideal candidate has experience with manufacturing processes, equipment maintenance, quality control, safety protocols, and working in a fast-paced production environment.";
            
            // Initialize TTS status
            updateTTSStatus();
            updateRecordingSupportUI();

            const candidateInput = document.getElementById('candidate-name');
            if (candidateInput) {
                candidateInput.addEventListener('input', (event) => {
                    appState.candidateName = event.target.value.trim();
                });
            }
            

        }
        


        function mimeTypeToExtension(mimeType) {
            if (!mimeType) {
                return 'webm';
            }
            const lower = mimeType.toLowerCase();
            const matched = MEDIA_RECORDER_PREFERENCES.find(option => option.type.toLowerCase() === lower);
            if (matched) {
                return matched.extension;
            }
            if (lower.includes('mp4')) return 'm4a';
            if (lower.includes('mpeg')) return 'mp3';
            if (lower.includes('ogg')) return 'ogg';
            if (lower.includes('wav')) return 'wav';
            return 'webm';
        }

        function detectRecordingSupport() {
            const result = {
                supported: typeof MediaRecorder !== 'undefined',
                mimeType: '',
                extension: 'webm',
                limited: false,
                reason: ''
            };

            if (appState && appState.recordingMimeType) {
                result.mimeType = appState.recordingMimeType;
                result.extension = appState.recordingExtension || mimeTypeToExtension(appState.recordingMimeType);
                return result;
            }

            if (!result.supported) {
                result.reason = 'MediaRecorder API unavailable';
                return result;
            }

            const canCheck = typeof MediaRecorder.isTypeSupported === 'function';
            if (canCheck) {
                for (const option of MEDIA_RECORDER_PREFERENCES) {
                    try {
                        if (MediaRecorder.isTypeSupported(option.type)) {
                            result.mimeType = option.type;
                            result.extension = option.extension;
                            return result;
                        }
                    } catch (error) {
                        // Ignore unsupported mime strings
                    }
                }
                result.limited = true;
            } else {
                result.limited = true;
            }

            if (result.limited && IS_SAFARI) {
                result.extension = 'm4a';
            }

            return result;
        }

        function updateRecordingSupportUI() {
            const statusEl = document.getElementById('recorder-status');
            const warningEl = document.getElementById('recorder-warning');
            const startButton = document.getElementById('start-recording-btn');
            const support = detectRecordingSupport();

            appState.recorderSupported = support.supported;
            if (!appState.recordingMimeType && support.mimeType) {
                appState.recordingMimeType = support.mimeType;
            }
            if (!appState.recordingExtension && support.extension) {
                appState.recordingExtension = support.extension;
            }

            if (!statusEl) {
                return;
            }

            if (!support.supported) {
                statusEl.className = 'inline-flex items-center px-2 py-1 rounded bg-red-100 text-red-800';
                statusEl.textContent = 'Live recording not supported';
                if (warningEl) {
                    warningEl.classList.remove('hidden');
                    warningEl.textContent = 'Your browser does not support live audio recording. Please upload an audio file for each response.';
                }
                if (startButton) {
                    startButton.disabled = true;
                    startButton.classList.add('opacity-50', 'cursor-not-allowed');
                }
                return;
            }

                if (!IS_SECURE_CONTEXT) {
                statusEl.className = 'inline-flex items-center px-2 py-1 rounded bg-yellow-100 text-yellow-800';
                statusEl.textContent = 'Recording blocked on HTTP';
                if (warningEl) {
                    warningEl.classList.remove('hidden');
                    warningEl.innerHTML = 'Browsers generally restrict microphone capture to HTTPS or localhost. Please switch to <strong>https://</strong> (self-signed is okay) or use the upload option to provide audio.';
                }
                if (startButton) {
                    startButton.disabled = true;
                    startButton.classList.add('opacity-50', 'cursor-not-allowed');
                }
                return;
            }

            if (warningEl) {
                warningEl.classList.add('hidden');
                warningEl.textContent = 'Live recording may be unavailable on this device. You can always upload an audio file below.';
            }

            if (support.limited) {
                statusEl.className = 'inline-flex items-center px-2 py-1 rounded bg-yellow-100 text-yellow-800';
                statusEl.textContent = 'Recording support limited';
                if (warningEl) {
                    warningEl.classList.remove('hidden');
                    warningEl.textContent = 'Your browser offers limited recording support. If recording fails, use the upload option below.';
                }
            } else {
                const label = (support.extension || 'webm').toUpperCase();
                statusEl.className = 'inline-flex items-center px-2 py-1 rounded bg-green-100 text-green-800';
                statusEl.textContent = `Recording ready (${label})`;
            }

            if (startButton) {
                startButton.disabled = false;
                startButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        function resumeAudioContextOnInteraction() {
            if (!appState.audioContext || appState.audioResumeHandlerAttached) {
                return;
            }
            if (appState.audioContext.state !== 'suspended') {
                return;
            }

            const resume = () => {
                appState.audioContext.resume().catch(() => {});
                window.removeEventListener('touchend', resume, true);
                window.removeEventListener('click', resume, true);
                window.removeEventListener('keydown', resume, true);
                appState.audioResumeHandlerAttached = false;
            };

            appState.audioResumeHandlerAttached = true;
            window.addEventListener('touchend', resume, true);
            window.addEventListener('click', resume, true);
            window.addEventListener('keydown', resume, true);
        }

        async function checkServerHealth() {
            const indicator = document.getElementById('server-indicator');
            const status = document.getElementById('server-status');
            const apiInfo = document.getElementById('api-info');

            try {
                console.log('Health check starting...');

                const response = await makeAPIRequest('/health', {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-cache'
                });

                const data = await response.json();
                console.log('Server health check successful:', data);

                indicator.className = 'w-2 h-2 bg-green-400 rounded-full animate-pulse';
                status.textContent = 'Server Online';
                status.className = 'text-xs text-green-300';

                if (apiInfo) {
                    apiInfo.textContent = `API: ${getApiHostDisplay()}`;
                    apiInfo.className = 'text-xs text-blue-200 opacity-75';
                }
                // Update LLM status display if present in the health payload
                const llmStatus = document.getElementById('llm-status');
                if (llmStatus) {
                    const llm = data.llm || data.services?.llm || 'unknown';
                    llmStatus.textContent = `LLM: ${llm}`;
                    if (llm === 'available') {
                        llmStatus.className = 'ml-3 text-xs text-green-300';
                    } else if (llm === 'unavailable') {
                        llmStatus.className = 'ml-3 text-xs text-red-300';
                        const reason = data.llm_reason || data.llm_reason || '';
                        if (reason) {
                            llmStatus.textContent = `LLM: ${llm} (${reason})`;
                        }
                    } else {
                        llmStatus.className = 'ml-3 text-xs text-yellow-200';
                    }
                }

                // Update TTS status and disable play button if unavailable
                const ttsStatus = data.services?.tts || 'unknown';
                window.ttsAvailable = ttsStatus === 'available';
                const playBtn = document.getElementById('play-question-btn');
                if (playBtn) {
                    if (window.ttsAvailable) {
                        playBtn.disabled = false;
                        playBtn.title = '';
                        playBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    } else {
                        playBtn.disabled = true;
                        playBtn.title = 'TTS unavailable - cannot play questions';
                        playBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                }

            } catch (error) {
                console.error('Server health check failed:', error);

                indicator.className = 'w-2 h-2 bg-red-400 rounded-full animate-pulse';

                let errorMessage = 'Server Offline';
                let troubleshootingHint = '';

                if (error?.message?.includes('timeout') || error?.name === 'AbortError') {
                    errorMessage = 'Server Timeout';
                    troubleshootingHint = 'Server may be starting up or overloaded';
                } else if (error?.message?.includes('fetch') || error?.message?.includes('Failed to fetch')) {
                    errorMessage = 'Connection Failed';
                    if (window.location.protocol === 'https:') {
                        troubleshootingHint = `Visit ${API_BASE}/health directly and accept the certificate`;
                    } else {
                        troubleshootingHint = 'Check if server is running and accessible';
                    }
                } else if (error?.message?.toLowerCase().includes('certificate') || error?.message?.toLowerCase().includes('ssl') || error?.message?.toLowerCase().includes('tls')) {
                    errorMessage = 'Certificate Error';
                    troubleshootingHint = `Visit ${API_BASE}/health and accept the self-signed certificate`;
                }

                status.textContent = errorMessage;
                status.className = 'text-xs text-red-300';

                if (apiInfo) {
                    if (troubleshootingHint) {
                        apiInfo.textContent = troubleshootingHint;
                        apiInfo.className = 'text-xs text-yellow-200';
                    } else {
                        apiInfo.textContent = `API: ${getApiHostDisplay()} (offline)`;
                        apiInfo.className = 'text-xs text-yellow-200';
                    }
                }
            }
        }

        // Microphone Permission Handling
        async function ensureMicPermission() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    const unsupportedError = new Error('Microphone access is not supported on this device.');
                    unsupportedError.name = 'NotSupportedError';
                    throw unsupportedError;
                }
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                appState.micPermission = true;
                appState.micStream = stream;
                
                // Update mic status
                const micStatus = document.getElementById('mic-status');
                micStatus.className = 'inline-flex items-center px-2 py-1 rounded bg-green-100 text-green-800';
                micStatus.textContent = 'Mic access granted';
                
                // Hide mic error if shown
                document.getElementById('mic-error').style.display = 'none';
                document.getElementById('mic-warning').style.display = 'none';
                
                // Setup audio context for level monitoring
                setupAudioContext(stream);
                resumeAudioContextOnInteraction();
                updateRecordingSupportUI();
                
                return true;
            } catch (error) {
                appState.micPermission = false;
                showMicError(error);
                updateRecordingSupportUI();
                return false;
            }
        }

        function showMicError(error) {
            const micError = document.getElementById('mic-error');
            const micStatus = document.getElementById('mic-status');
            
            let errorMessage = 'Microphone access denied. ';
            if (error.name === 'NotAllowedError') {
                errorMessage += 'Please allow microphone access in your browser settings and refresh the page.';
            } else if (error.name === 'NotFoundError') {
                errorMessage += 'No microphone found. Please check your audio devices.';
            } else if (error.name === 'NotSupportedError') {
                errorMessage = 'This browser does not support live microphone access. Please switch to a modern browser or upload audio files manually.';
            } else {
                errorMessage += error.message;
            }
            
            micError.textContent = errorMessage;
            micError.style.display = 'block';
            
            micStatus.className = 'inline-flex items-center px-2 py-1 rounded bg-red-100 text-red-800';
            micStatus.textContent = 'Mic access denied';
        }

        function setupAudioContext(stream) {
            try {
                appState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = appState.audioContext.createMediaStreamSource(stream);
                const analyser = appState.audioContext.createAnalyser();
                
                analyser.fftSize = 512;
                const frequencyData = new Uint8Array(analyser.frequencyBinCount);
                const timeDomainData = new Uint8Array(analyser.fftSize);
                let monitorRunning = false;
                
                source.connect(analyser);
                
                function updateMicLevel() {
                    if (!monitorRunning) {
                        return;
                    }

                    analyser.getByteFrequencyData(frequencyData);
                    analyser.getByteTimeDomainData(timeDomainData);

                    const average = frequencyData.reduce((sum, val) => sum + val, 0) / frequencyData.length;
                    const percentage = Math.min(100, (average / 128) * 100);
                    
                    const micLevel = document.getElementById('mic-level');
                    if (micLevel) {
                        micLevel.style.width = percentage + '%';
                        micLevel.className = percentage > 30 ? 'h-2 bg-green-500 rounded mic-level' : 'h-2 bg-yellow-500 rounded mic-level';
                    }

                    if (appState.isRecording) {
                        // Calculate RMS for silence/noise detection
                        let sumSquares = 0;
                        for (let i = 0; i < timeDomainData.length; i++) {
                            const normalized = (timeDomainData[i] - 128) / 128;
                            sumSquares += normalized * normalized;
                        }
                        const rms = Math.sqrt(sumSquares / timeDomainData.length);

                        // Calculate zero crossing rate
                        let zeroCrossings = 0;
                        let lastSign = null;
                        for (let i = 0; i < timeDomainData.length; i++) {
                            const normalized = (timeDomainData[i] - 128) / 128;
                            const sign = normalized >= 0 ? 1 : -1;
                            if (lastSign !== null && sign !== lastSign) {
                                zeroCrossings++;
                            }
                            lastSign = sign;
                        }
                        const zcr = zeroCrossings / timeDomainData.length;

                        const now = performance.now();

                        // Check if user is speaking (above silence threshold and below noise threshold)
                        const isSpeaking = rms > SILENCE_THRESHOLD && !(rms > NOISE_RMS_THRESHOLD && zcr > NOISE_ZCR_THRESHOLD);
                        
                        // Detect when speaking starts
                        if (isSpeaking && !appState.speakingDetected) {
                            appState.speakingDetected = true;
                            appState.speakingStartTime = now;
                            console.log('üé§ Speaking detected, auto-stop timer will start after silence/noise');
                            // Reset silence and noise timers
                            appState.silenceStart = null;
                            appState.noiseStart = null;
                        }
                        
                        // Only start counting silence/noise AFTER speaking has been detected
                        if (appState.speakingDetected) {
                            if (rms < SILENCE_THRESHOLD) {
                                // User is silent after speaking started
                                if (!appState.silenceStart) {
                                    appState.silenceStart = now;
                                    console.log('üîá Silence detected after speaking, starting 5-second timer');
                                } else if (now - appState.silenceStart >= SILENCE_DURATION_MS) {
                                    console.log('üîá 5 seconds of silence detected, auto-stopping recording');
                                    autoStopRecording('silence');
                                    requestAnimationFrame(updateMicLevel);
                                    return;
                                }
                                // Reset noise timer since we're in silence
                                appState.noiseStart = null;
                            } else if (rms > NOISE_RMS_THRESHOLD && zcr > NOISE_ZCR_THRESHOLD) {
                                // User has excessive noise after speaking started
                                if (!appState.noiseStart) {
                                    appState.noiseStart = now;
                                    console.log('üì¢ Excessive noise detected after speaking, starting 5-second timer');
                                } else if (now - appState.noiseStart >= NOISE_DURATION_MS) {
                                    console.log('üì¢ 5 seconds of excessive noise detected, auto-stopping recording');
                                    autoStopRecording('noise');
                                    requestAnimationFrame(updateMicLevel);
                                    return;
                                }
                                // Reset silence timer since we're in noise
                                appState.silenceStart = null;
                            } else {
                                // User is speaking normally, reset both timers
                                appState.silenceStart = null;
                                appState.noiseStart = null;
                            }
                        }
                    } else {
                        // Reset all speaking detection when not recording
                        appState.silenceStart = null;
                        appState.noiseStart = null;
                        appState.speakingDetected = false;
                        appState.speakingStartTime = null;
                    }

                    requestAnimationFrame(updateMicLevel);
                }

                appState.micLevelUpdate = () => {
                    if (!monitorRunning) {
                        monitorRunning = true;
                        requestAnimationFrame(updateMicLevel);
                    }
                };

                appState.stopMicMonitor = () => {
                    monitorRunning = false;
                };

                appState.micLevelUpdate();
            } catch (error) {
                console.warn('Audio context setup failed:', error);
            }
        }

        function updateTTSStatus() {
            const ttsStatus = document.getElementById('tts-status');
            ttsStatus.className = 'inline-flex items-center px-2 py-1 rounded bg-green-100 text-green-800';
            ttsStatus.textContent = 'Voice ready';
        }

        function showRecordingAlert(message, tone = 'warning') {
            const alert = document.getElementById('recording-alert');
            const alertText = document.getElementById('recording-alert-text');
            if (!alert || !alertText) return;

            alert.classList.remove('hidden', 'bg-yellow-50', 'text-yellow-800', 'border-yellow-300', 'bg-red-50', 'text-red-800', 'border-red-200', 'bg-blue-50', 'text-blue-800', 'border-blue-200');

            switch (tone) {
                case 'error':
                    alert.classList.add('bg-red-50', 'text-red-800', 'border-red-200');
                    break;
                case 'info':
                    alert.classList.add('bg-blue-50', 'text-blue-800', 'border-blue-200');
                    break;
                default:
                    alert.classList.add('bg-yellow-50', 'text-yellow-800', 'border-yellow-300');
            }

            alert.classList.remove('hidden');
            alertText.textContent = message;
        }

        function hideRecordingAlert() {
            const alert = document.getElementById('recording-alert');
            if (!alert) return;
            alert.classList.add('hidden');
        }

        function autoStopRecording(reason) {
            if (!appState.isRecording || !appState.mediaRecorder) return;
            if (appState.autoStopReason) return;
            appState.autoStopReason = reason;
            
            // Provide user feedback
            if (reason === 'silence') {
                showRecordingAlert('üîá Recording stopped automatically - 5 seconds of silence detected after speaking', 'info');
            } else if (reason === 'noise') {
                showRecordingAlert('üì¢ Recording stopped automatically - 5 seconds of excessive noise detected after speaking', 'info');
            }
            
            stopRecording(true);
        }

        // Question Generation
        async function handleGenerateQuestions() {
            const jobDescription = document.getElementById('job-description').value.trim();
            const jobRole = document.getElementById('job-role-input').value.trim();
            const numQuestions = parseInt(document.getElementById('num-questions').value);
            const candidateNameInput = document.getElementById('candidate-name');
            const candidateName = candidateNameInput ? candidateNameInput.value.trim() : '';
            
            if (!jobDescription) {
                alert('Please enter a job description');
                return;
            }

            appState.jobDescription = jobDescription;
            appState.jobRole = jobRole;
            appState.candidateName = candidateName;
            appState.numQuestions = numQuestions;
            
            const generateBtn = document.getElementById('generate-btn');
            const loadingMessage = document.getElementById('loading-message');
            const loadingText = document.getElementById('loading-text');
            
            // Show loading state
            generateBtn.disabled = true;
            loadingMessage.style.display = 'block';
            loadingText.textContent = 'Generating questions with AI...';
            
            const prompt = `Generate ${numQuestions} interview questions for this job description:\n\n${jobDescription}\n\nProvide only the questions, numbered 1-${numQuestions}.`;
            
            try {
                console.log('Making request to:', `${API_BASE}/generate`);
                console.log('Request data:', {
                    job_description: jobDescription,
                    job_role: jobRole || null,
                    num_questions: numQuestions
                });

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                const response = await makeAPIRequest('/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        job_description: jobDescription,
                        job_role: jobRole || null,
                        num_questions: numQuestions
                    }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                const result = await response.json();

                if (response.ok) {
                    let questionsList = Array.isArray(result.questions) ? result.questions.filter(q => q && q.trim()) : [];

                    if (questionsList.length === 0 && typeof result.content === 'string') {
                        const parsed = result.content.split('\n').map(line => line.replace(/^\d+[).\-]?\s*/, '').trim()).filter(Boolean);
                        questionsList = parsed.slice(0, numQuestions);
                    }

                    if (questionsList.length === 0) {
                        throw new Error('No questions were generated.');
                    }

                    appState.questions = questionsList;
                    window.interviewQuestions = questionsList; // Also store globally for consistency
                    appState.questionSource = result.source || 'unknown';
                    appState.usedFallback = Boolean(result.used_fallback);
                    appState.fallbackReason = result.fallback_reason || '';

                    displayGeneratedQuestions();
                    appState.currentScreen = 'questions_generated';
                } else {
                    throw new Error(result.detail || 'Failed to generate questions');
                }
            } catch (error) {
                console.error('Full error details:', error);
                console.error('Error type:', error.name);
                console.error('Error message:', error.message);
                console.error('API URL attempted:', `${API_BASE}/generate`);
                
                let errorMessage = 'Unknown error occurred';
                let troubleshootingTip = '';
                
                if (error.name === 'AbortError') {
                    errorMessage = 'Request timed out (30 seconds). Please try again.';
                    troubleshootingTip = 'Server may be overloaded or starting up.';
                } else if (error.name === 'TypeError' && (error.message.includes('fetch') || error.message.includes('Failed to fetch'))) {
                    errorMessage = 'Cannot connect to server';
                    if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                        troubleshootingTip = `Network testing detected. Make sure the server is running at ${API_BASE} and accessible from this device.`;
                    } else {
                        troubleshootingTip = 'Please check if the server is running locally.';
                    }
                } else if (error.message && error.message.includes('CORS')) {
                    errorMessage = 'Cross-origin request blocked';
                    troubleshootingTip = 'Server CORS configuration may need updating for network access.';
                } else if (error.message && error.message.includes('Load failed')) {
                    errorMessage = 'Connection failed - server unreachable';
                    troubleshootingTip = `Cannot reach server at ${API_BASE}. Check server status and network connectivity.`;
                } else {
                    errorMessage = error.message || 'Request failed';
                    troubleshootingTip = 'Check console for detailed error information.';
                }
                
                const fullMessage = troubleshootingTip ? 
                    `${errorMessage}\n\nüí° ${troubleshootingTip}` : 
                    errorMessage;
                
                alert('Error generating questions: ' + fullMessage);
            } finally {
                generateBtn.disabled = false;
                loadingMessage.style.display = 'none';
            }
        }

        function displayGeneratedQuestions() {
            const questionsContainer = document.getElementById('questions-list');
            const generatedSection = document.getElementById('generated-questions');
            
            questionsContainer.innerHTML = '';
            
            appState.questions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'p-3 bg-gray-50 rounded border';
                questionDiv.innerHTML = `
                    <strong>Question ${index + 1}:</strong> ${question}
                `;
                questionsContainer.appendChild(questionDiv);
            });

            const statusNote = document.createElement('div');
            statusNote.className = 'mt-4 text-sm flex items-start gap-2';

            if (appState.usedFallback) {
                statusNote.innerHTML = `
                    <span class="inline-flex h-2 w-2 rounded-full bg-yellow-500 mt-1"></span>
                    <span class="p-3 rounded border border-yellow-200 bg-yellow-50 text-yellow-800">
                        Generated using built-in templates because the language model was unavailable.
                        ${appState.fallbackReason ? `<br/><span class="text-xs text-yellow-700">Reason: ${appState.fallbackReason}</span>` : ''}
                    </span>
                `;
            } else {
                statusNote.innerHTML = `
                    <span class="inline-flex h-2 w-2 rounded-full bg-green-500 mt-1"></span>
                    <span class="p-3 rounded border border-green-200 bg-green-50 text-green-800">
                        Questions generated via ${appState.questionSource === 'ollama' ? 'Gemma 3:27B' : appState.questionSource}.
                    </span>
                `;
            }

            questionsContainer.appendChild(statusNote);
            
            generatedSection.style.display = 'block';
        }

        function showQuestionReview() {
            // Hide setup section, show review section
            document.getElementById('setup-section').style.display = 'none';
            document.getElementById('review-section').style.display = 'block';
            
            const questionsToShow = appState.questions || window.interviewQuestions || [];
            console.log('Questions to show in review:', questionsToShow);
            displayQuestionsForReview(questionsToShow);
            appState.currentScreen = 'questions_approved';
        }

        // Display questions for review
        function displayQuestionsForReview(questions) {
            const reviewSection = document.getElementById('review-section');
            const questionsList = document.getElementById('review-questions-list');
            questionsList.innerHTML = '';

            if (!questions || !Array.isArray(questions) || questions.length === 0) {
                console.log('No questions to display:', questions);
                questionsList.innerHTML = '<li class="p-3 text-gray-500 text-center">No questions generated</li>';
                return;
            }

            console.log('Displaying questions:', questions);
            questions.forEach((q, index) => {
                const li = document.createElement('li');
                li.className = 'flex items-start gap-3 p-4 bg-white border border-gray-200 rounded-lg mb-3 shadow-sm hover:shadow-md transition-all duration-200 hover:border-blue-300';
                li.dataset.index = index;

                // Drag handle
                const dragHandle = document.createElement('div');
                dragHandle.innerHTML = '‚ò∞';
                dragHandle.className = 'text-gray-400 text-lg leading-none pt-1 cursor-move select-none hover:text-gray-600';
                dragHandle.title = 'Drag to reorder';
                dragHandle.style.userSelect = 'none';
                dragHandle.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                });
                dragHandle.addEventListener('selectstart', function(e) {
                    e.preventDefault();
                });

                // Checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2 mt-1 no-drag';
                checkbox.checked = false; // Default to not selected
                checkbox.addEventListener('change', updateApprovalCount);

                // Question content
                const contentDiv = document.createElement('div');
                contentDiv.className = 'flex-grow';
                
                const questionNumber = document.createElement('div');
                questionNumber.textContent = `Question ${index + 1}`;
                questionNumber.className = 'text-sm font-semibold text-blue-600 mb-1';
                
                const textSpan = document.createElement('div');
                textSpan.textContent = q;
                textSpan.className = 'text-gray-800 leading-relaxed';

                contentDiv.appendChild(questionNumber);
                contentDiv.appendChild(textSpan);

                // Edit button
                const editButton = document.createElement('button');
                editButton.innerHTML = '‚úèÔ∏è';
                editButton.title = 'Edit with AI';
                editButton.className = 'text-gray-500 hover:text-blue-600 p-2 rounded-full hover:bg-blue-50 transition-colors duration-200 flex-shrink-0 no-drag';
                editButton.onclick = (e) => {
                    e.stopPropagation();
                    openEditModal(index);
                };
                
                li.appendChild(dragHandle);
                li.appendChild(checkbox);
                li.appendChild(contentDiv);
                li.appendChild(editButton);
                questionsList.appendChild(li);
            });

            reviewSection.classList.remove('hidden');
            const approveBtn = document.getElementById('approve-btn');
            if (approveBtn) {
                approveBtn.classList.remove('hidden');
            }
            
            // Initialize SortableJS if it's not already
            if (window.sortable) {
                window.sortable.destroy();
            }
            window.sortable = new Sortable(questionsList, {
                animation: 150,
                ghostClass: 'opacity-50',
                chosenClass: 'bg-blue-50',
                dragClass: 'opacity-75',
                forceFallback: true,
                preventOnFilter: false,
                filter: 'input, textarea, button, .no-drag',
                onStart: function() {
                    document.body.style.userSelect = 'none';
                    document.body.classList.add('no-select');
                },
                onEnd: function (evt) {
                    document.body.style.userSelect = '';
                    document.body.classList.remove('no-select');
                    const oldIndex = evt.oldDraggableIndex;
                    const newIndex = evt.newDraggableIndex;

                    if (oldIndex !== newIndex) {
                        // Reorder the questions array
                        const questionsToReorder = window.interviewQuestions || appState.questions || [];
                        const [movedItem] = questionsToReorder.splice(oldIndex, 1);
                        questionsToReorder.splice(newIndex, 0, movedItem);
                        
                        // Update both storage locations
                        window.interviewQuestions = questionsToReorder;
                        appState.questions = questionsToReorder;
                        
                        // Re-render to fix indices and display
                        displayQuestionsForReview(questionsToReorder);
                    }
                }
            });
            
            // Update approval count after rendering - ensure DOM is fully rendered
            // Try immediate update first
            updateApprovalCount();
            
            // Also schedule a delayed update as backup
            setTimeout(() => {
                updateApprovalCount();
                console.log('‚úÖ Questions rendered for review. Count updated with delay.');
            }, 200);
        }

        // --- Edit Modal Logic ---
        function openEditModal(index) {
            const modal = document.getElementById('edit-modal');
            const questionText = document.getElementById('edit-question-text');
            const instructionInput = document.getElementById('edit-instruction');
            
            window.currentEditIndex = index;
            questionText.textContent = window.interviewQuestions[index];
            instructionInput.value = '';
            
            modal.classList.remove('hidden');
            instructionInput.focus();
        }

        function closeEditModal() {
            document.getElementById('edit-modal').classList.add('hidden');
        }

        async function submitEditedQuestion() {
            const instruction = document.getElementById('edit-instruction').value;
            if (!instruction.trim()) {
                alert('Please provide an instruction to edit the question.');
                return;
            }

            const questionsArray = window.interviewQuestions || appState.questions || [];
            const originalQuestion = questionsArray[window.currentEditIndex];
            const jobDescription = document.getElementById('job-description').value || '';
            const jobRole = document.getElementById('job-role-input').value || '';

            if (!originalQuestion) {
                alert('Error: Could not find the original question to edit.');
                return;
            }

            const submitBtn = document.getElementById('submit-edit-btn');
            const originalText = submitBtn.innerHTML;
            submitBtn.disabled = true;
            submitBtn.innerHTML = '‚è≥ Editing...';

            try {
                console.log('Editing question:', {
                    original_question: originalQuestion,
                    edit_instruction: instruction,
                    job_description: jobDescription,
                    job_role: jobRole,
                    index: window.currentEditIndex
                });

                const response = await fetch(`${API_BASE}/questions/edit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        original_question: originalQuestion,
                        edit_instruction: instruction,
                        job_description: jobDescription,
                        job_role: jobRole
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error Response:', errorText);
                    try {
                        const error = JSON.parse(errorText);
                        throw new Error(error.detail || 'Failed to edit question.');
                    } catch {
                        throw new Error(`HTTP Error ${response.status}: ${errorText}`);
                    }
                }

                const result = await response.json();
                console.log('Edit result:', result);
                
                if (!result.edited_question) {
                    throw new Error('No edited question returned from server.');
                }
                
                // Update the question in the array
                questionsArray[window.currentEditIndex] = result.edited_question;
                window.interviewQuestions = questionsArray;
                if (appState.questions) {
                    appState.questions = questionsArray;
                }
                
                // Re-render the questions
                displayQuestionsForReview(questionsArray);
                closeEditModal();
                
                // Show success message
                const successMsg = document.createElement('div');
                successMsg.className = 'fixed top-4 right-4 bg-green-500 text-white p-3 rounded-lg shadow-lg z-50';
                successMsg.textContent = 'Question updated successfully!';
                document.body.appendChild(successMsg);
                setTimeout(() => successMsg.remove(), 3000);

            } catch (error) {
                console.error('Error editing question:', error);
                alert(`Error editing question: ${error.message}`);
            } finally {
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalText;
            }
        }
        // ----------------------

        // Update approval count
        function updateApprovalCount() {
            const checkboxes = document.querySelectorAll('#review-questions-list input[type="checkbox"]');
            const checkedCount = document.querySelectorAll('#review-questions-list input[type="checkbox"]:checked').length;
            const totalCount = checkboxes.length;
            
            console.log('üîç Debugging updateApprovalCount:');
            console.log('   - Checkboxes found:', checkboxes.length);
            console.log('   - Checked count:', checkedCount);
            console.log('   - Review questions list element:', document.getElementById('review-questions-list'));
            console.log('   - Questions in appState:', appState.questions?.length || 0);
            console.log('   - Questions in window.interviewQuestions:', window.interviewQuestions?.length || 0);
            
            // Update the green counter at the top with class selector
            const topCountElement = document.querySelector('.approval-count');
            if (topCountElement) {
                topCountElement.textContent = `${checkedCount} of ${totalCount} questions approved`;
            }

            // Update the bottom status with ID selector
            const bottomCountElement = document.getElementById('approval-count');
            if (bottomCountElement) {
                bottomCountElement.textContent = `${checkedCount} of ${totalCount} questions approved`;
            }

            // Enable/disable the approve button based on selection
            const approveBtn = document.getElementById('approve-btn');
            if (approveBtn) {
                if (checkedCount > 0) {
                    approveBtn.disabled = false;
                    approveBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    approveBtn.style.opacity = '1';
                } else {
                    approveBtn.disabled = true;
                    approveBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    approveBtn.style.opacity = '0.5';
                }
            }
        }

        // Select all questions
        function selectAllQuestions() {
            console.log('Selecting all questions');
            const checkboxes = document.querySelectorAll('#review-questions-list input[type="checkbox"]');
            console.log('Found checkboxes:', checkboxes.length);
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateApprovalCount();
        }

        // Clear all question selections
        function clearAllQuestions() {
            console.log('Clearing all questions');
            const checkboxes = document.querySelectorAll('#review-questions-list input[type="checkbox"]');
            console.log('Found checkboxes:', checkboxes.length);
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            updateApprovalCount();
        }

        // Go back to setup screen
        function goBackToSetup() {
            console.log('Going back to setup screen');
            const reviewSection = document.getElementById('review-section');
            const setupSection = document.getElementById('setup-section');
            
            if (reviewSection) {
                reviewSection.style.display = 'none';
                reviewSection.classList.add('hidden');
            }
            
            if (setupSection) {
                setupSection.style.display = 'block';
                setupSection.classList.remove('hidden');
            }
            
            // Update app state
            appState.currentScreen = 'setup';
            
            console.log('Switched to setup screen');
        }

        // Approve questions and start interview
        async function approveAndStartInterview() {
            console.log('Approve and start interview clicked');
            const checkedBoxes = document.querySelectorAll('#review-questions-list input[type="checkbox"]:checked');
            console.log('Found checked boxes:', checkedBoxes.length);
            
            if (checkedBoxes.length === 0) {
                alert('Please select at least one question to proceed with the interview.');
                return;
            }

            // Get the current ordered list of questions
            const questionsArray = window.interviewQuestions || appState.questions || [];
            
            // Get selected questions in their current display order (not using dataset.index)
            const selectedQuestions = [];
            const listItems = document.querySelectorAll('#review-questions-list li');
            
            listItems.forEach((li, displayIndex) => {
                const checkbox = li.querySelector('input[type="checkbox"]');
                if (checkbox && checkbox.checked) {
                    // Use the display index to get the question from the current ordered array
                    if (questionsArray[displayIndex]) {
                        selectedQuestions.push(questionsArray[displayIndex]);
                    }
                }
            });

            console.log('Selected questions:', selectedQuestions);

            if (selectedQuestions.length === 0) {
                alert('No valid questions selected. Please try again.');
                return;
            }

            // Update the questions arrays with only the selected and correctly ordered questions
            window.interviewQuestions = selectedQuestions;
            appState.questions = selectedQuestions;
            appState.approvedQuestions = selectedQuestions; // Ensure approvedQuestions is also set

            console.log('Starting interview with selected questions:', selectedQuestions);

            // Start the interview
            await startInterview();
        }

        // Start interview
        async function startInterview() {
            // Use the already selected and validated questions from approveAndStartInterview
            if (!appState.approvedQuestions || appState.approvedQuestions.length === 0) {
                alert('Please select at least one question');
                return;
            }
            
            // Ensure microphone permission
            if (!appState.micPermission) {
                const hasPermission = await ensureMicPermission();
                if (!hasPermission) {
                    const micWarning = document.getElementById('mic-warning');
                    const micWarningText = document.getElementById('mic-warning-text');
                    if (micWarning) {
                        micWarning.style.display = 'block';
                    }
                    if (micWarningText) {
                        micWarningText.textContent = 'Microphone access is unavailable in this browser. You can still continue by uploading audio after each question.';
                    }
                    updateRecordingSupportUI();
                }
            }
            
            const approveBtn = document.getElementById('approve-btn');
            const originalApproveMarkup = approveBtn ? approveBtn.innerHTML : '';
            if (approveBtn) {
                approveBtn.disabled = true;
                approveBtn.classList.add('opacity-75', 'cursor-not-allowed');
                approveBtn.innerHTML = `
                    <span class="flex items-center gap-3">
                        <svg class="w-5 h-5 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke-width="4"></circle>
                            <path class="opacity-75" d="M4 12a8 8 0 018-8" stroke-width="4" stroke-linecap="round"></path>
                        </svg>
                        Starting interview...
                    </span>`;
            }

            try {
                const candidateInput = document.getElementById('candidate-name');
                const latestCandidateName = candidateInput ? candidateInput.value.trim() : '';
                const latestJobRoleInput = document.getElementById('job-role-input');
                const latestJobRole = latestJobRoleInput ? latestJobRoleInput.value.trim() : '';
                const latestJobDescription = document.getElementById('job-description').value.trim();

                appState.candidateName = latestCandidateName;
                appState.jobRole = latestJobRole;
                appState.jobDescription = latestJobDescription;

                const payload = {
                    candidate_name: latestCandidateName || null,
                    job_role: latestJobRole || null,
                    job_description: latestJobDescription || null,
                    num_questions: appState.approvedQuestions.length,
                    questions: appState.approvedQuestions,
                };

                console.log('Sending interview start payload:', payload);
                console.log('API endpoint:', `${API_BASE}/interview/start`);

                const response = await fetch(`${API_BASE}/interview/start`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                });

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const result = await response.json();
                        if (result.detail) {
                            if (Array.isArray(result.detail)) {
                                // Validation errors from FastAPI
                                errorMessage = result.detail.map(err => `${err.loc.join('.')}: ${err.msg}`).join(', ');
                            } else {
                                errorMessage = result.detail;
                            }
                        }
                    } catch (e) {
                        // If we can't parse JSON, use the status text
                        console.error('Could not parse error response:', e);
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();

                appState.sessionId = result.session_id;
                if (Array.isArray(result.questions) && result.questions.length > 0) {
                    appState.approvedQuestions = result.questions;
                }
                appState.currentQuestionIndex = 0;
                appState.responses = [];
                appState.questionSource = result.question_source || appState.questionSource;
                appState.usedFallback = Boolean(result.used_fallback);

                // Hide review section, show interview section
                document.getElementById('review-section').style.display = 'none';
                document.getElementById('interview-section').style.display = 'block';
                
                appState.currentScreen = 'in_progress';
                displayCurrentQuestion();
            } catch (error) {
                alert('Error starting interview: ' + error.message);
                if (approveBtn) {
                    approveBtn.disabled = false;
                    approveBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                    approveBtn.innerHTML = originalApproveMarkup;
                }
            }
        }

        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Interview Progress
        function displayCurrentQuestion() {
            const questionTitle = document.getElementById('question-title');
            const questionText = document.getElementById('current-question-text');
            const progressBar = document.getElementById('progress-bar');
            
            const currentIndex = appState.currentQuestionIndex;
            const totalQuestions = appState.approvedQuestions.length;
            
            if (currentIndex < totalQuestions) {
                questionTitle.textContent = `Question ${currentIndex + 1} of ${totalQuestions}`;
                questionText.textContent = appState.approvedQuestions[currentIndex];
                
                const progressPercentage = ((currentIndex + 1) / totalQuestions) * 100;
                progressBar.style.width = progressPercentage + '%';
                
                stopQuestionAudio();
                // Reset UI state for new question
                resetQuestionUI();

                // Skip autoplay entirely when TTS is unavailable
                // User will read the question and manually start recording
            } else {
                completeInterview();
            }
        }

        function resetQuestionUI() {
            // Hide transcription display
            document.getElementById('transcription-display').style.display = 'none';
            const postActions = document.getElementById('post-response-actions');
            if (postActions) {
                postActions.classList.add('hidden');
            }
            const nextButton = document.getElementById('next-question-btn');
            if (nextButton) {
                nextButton.disabled = true;
                nextButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
            const redoButton = document.getElementById('redo-question-btn');
            if (redoButton) {
                redoButton.disabled = false;
            }
            hideRecordingAlert();
            appState.pendingResponse = null;
            appState.autoStopReason = null;
            appState.recordedBlob = null;
            appState.silenceStart = null;
            appState.noiseStart = null;
            
            // Reset recording buttons
            document.getElementById('start-recording-btn').style.display = 'inline-block';
            document.getElementById('stop-recording-btn').style.display = 'none';
            document.getElementById('start-recording-btn').disabled = false;
            
            // Reset audio upload
            document.getElementById('audio-upload').value = '';
            
            // Reset play button
            const playBtn = document.getElementById('play-question-btn');
            if (window.ttsAvailable) {
                playBtn.disabled = false;
                playBtn.title = '';
                playBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                playBtn.disabled = true;
                playBtn.title = 'TTS unavailable - cannot play questions';
                playBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
            document.getElementById('play-btn-text').textContent = 'Play Question';
            
            // Reset mic level
            const micLevel = document.getElementById('mic-level');
            micLevel.style.width = '0%';
        }

        function stopQuestionAudio(resetPosition = true) {
            const playBtn = document.getElementById('play-question-btn');
            const playBtnText = document.getElementById('play-btn-text');

            if (appState.questionAudio) {
                try {
                    appState.questionAudio.pause();
                    if (resetPosition) {
                        appState.questionAudio.currentTime = 0;
                    }
                } catch (error) {
                    console.warn('Failed to stop question audio:', error);
                }
            }

            appState.questionAudio = null;

            appState.isPlayingQuestion = false;

            if (playBtn && window.ttsAvailable) {
                playBtn.disabled = false;
            }
            if (playBtnText) {
                playBtnText.textContent = 'Play Question';
            }
        }

        async function playCurrentQuestion(autoplay = false) {
            const playBtn = document.getElementById('play-question-btn');
            const playBtnText = document.getElementById('play-btn-text');
            
            if (appState.isPlayingQuestion) return;
            
            // Check if TTS is available before attempting to play
            if (!window.ttsAvailable) {
                console.warn('TTS is unavailable, cannot play question audio');
                return;
            }
            
            const questionText = appState.approvedQuestions[appState.currentQuestionIndex];
            
            try {
                playBtn.disabled = true;
                playBtnText.textContent = autoplay ? 'Preparing audio...' : 'Generating Audio...';
                appState.isPlayingQuestion = true;
                stopQuestionAudio();
                
                const response = await fetch(`${API_BASE}/synthesize`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text: questionText })
                });
                
                if (response.ok) {
                    const audioBlob = await response.blob();
                    const audioURL = URL.createObjectURL(audioBlob);
                    
                    if (appState.questionAudio) {
                        appState.questionAudio.pause();
                    }
                    
                    appState.questionAudio = new Audio(audioURL);
                    
                    playBtnText.textContent = 'Playing...';
                    
                    appState.questionAudio.onended = () => {
                        stopQuestionAudio(false);
                        // Automatically start recording after question finishes playing
                        setTimeout(() => {
                            startRecording().catch(error => {
                                console.warn('Auto-start recording failed:', error);
                            });
                        }, 500); // Small delay to allow UI to update
                    };
                    
                    appState.questionAudio.onerror = () => {
                        stopQuestionAudio(false);
                        alert('Error playing audio');
                    };
                    
                    await appState.questionAudio.play();
                } else {
                    throw new Error('Failed to synthesize audio');
                }
                
            } catch (error) {
                stopQuestionAudio(false);
                alert('Error playing question: ' + error.message);
            }
        }

        // Recording Functions
        async function startRecording() {
            // Re-check recording support if it's not available
            if (!appState.recorderSupported) {
                console.log('Recording support not available, re-checking...');
                updateRecordingSupportUI();
                
                // If still not supported after re-check, show error
                if (!appState.recorderSupported) {
                    showRecordingAlert('Live recording is not supported on this device. Please use the upload option below.', 'warning');
                    return;
                }
            }

            // Validate existing mic stream (handle revoked permissions or stopped tracks)
            if (appState.micStream) {
                const hasLiveTrack = appState.micStream.getAudioTracks().some(track => track.readyState === 'live');
                if (!hasLiveTrack) {
                    appState.micStream.getTracks().forEach(track => track.stop());
                    appState.micStream = null;
                    appState.micPermission = false;
                    console.warn('Existing microphone stream is no longer active. Requesting permission again.');
                }
            }

            if (!appState.micPermission || !appState.micStream) {
                const hasPermission = await ensureMicPermission();
                if (!hasPermission) {
                    const micWarningEl = document.getElementById('mic-warning');
                    if (micWarningEl) {
                        micWarningEl.style.display = 'block';
                    }
                    return;
                }
            }
            
            try {
                stopQuestionAudio();
                hideRecordingAlert();
                
                // Ensure audio context is running before starting recording
                if (appState.audioContext && appState.audioContext.state === 'suspended') {
                    console.log('Resuming suspended audio context before recording');
                    await appState.audioContext.resume();
                }
                
                // Reset recording state completely
                appState.autoStopReason = null;
                appState.pendingResponse = null;
                appState.silenceStart = null;
                appState.noiseStart = null;
                appState.speakingDetected = false;
                appState.speakingStartTime = null;
                appState.recordedBlob = null;
                appState.audioChunks = [];
                appState.isRecording = false;
                
                // Clear any existing MediaRecorder
                if (appState.mediaRecorder) {
                    try {
                        if (appState.mediaRecorder.state !== 'inactive') {
                            appState.mediaRecorder.stop();
                        }
                    } catch (e) {
                        console.log('Error stopping existing MediaRecorder:', e);
                    }
                    appState.mediaRecorder = null;
                }
                
                console.log('Starting recording - state reset complete');
                const postActions = document.getElementById('post-response-actions');
                if (postActions) {
                    postActions.classList.add('hidden');
                }
                const nextButton = document.getElementById('next-question-btn');
                if (nextButton) {
                    nextButton.disabled = true;
                    nextButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                const redoButton = document.getElementById('redo-question-btn');
                if (redoButton) {
                    redoButton.disabled = false;
                }
                document.getElementById('transcription-display').style.display = 'none';
                document.getElementById('transcription-text').textContent = '';

                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    const unsupported = new Error('Microphone access is not supported on this device.');
                    unsupported.name = 'NotSupportedError';
                    throw unsupported;
                }

                const stream = appState.micStream || await navigator.mediaDevices.getUserMedia({ audio: true });
                appState.micStream = stream;
                
                console.log('Stream active tracks:', stream.getAudioTracks().length);
                console.log('Stream state:', stream.getAudioTracks()[0]?.readyState);
                
                const recorderOptions = {};
                if (appState.recordingMimeType) {
                    recorderOptions.mimeType = appState.recordingMimeType;
                }

                console.log('Creating MediaRecorder with options:', recorderOptions);
                try {
                    appState.mediaRecorder = Object.keys(recorderOptions).length > 0
                        ? new MediaRecorder(stream, recorderOptions)
                        : new MediaRecorder(stream);
                    console.log('MediaRecorder created successfully, state:', appState.mediaRecorder.state);
                } catch (recorderError) {
                    if (recorderOptions.mimeType) {
                        console.warn('Recorder init failed for preferred mime type, retrying without it.', recorderError);
                        appState.recordingMimeType = '';
                        appState.recordingExtension = 'webm';
                        updateRecordingSupportUI();
                        appState.mediaRecorder = new MediaRecorder(stream);
                    } else {
                        throw recorderError;
                    }
                }
                
                appState.audioChunks = [];
                appState.isRecording = true;
                
                appState.mediaRecorder.ondataavailable = event => {
                    if (event.data && event.data.size > 0) {
                        appState.audioChunks.push(event.data);
                    }
                };
                
                appState.mediaRecorder.onstop = () => {
                    let detectedType = appState.recordingMimeType || '';
                    for (let i = 0; i < appState.audioChunks.length; i += 1) {
                        const chunk = appState.audioChunks[i];
                        if (chunk && chunk.type) {
                            detectedType = chunk.type;
                            break;
                        }
                    }
                    const blobType = detectedType || 'audio/webm';
                    appState.recordedBlob = new Blob(appState.audioChunks, { type: blobType });
                    appState.recordingMimeType = blobType;
                    appState.recordingExtension = mimeTypeToExtension(blobType);
                    updateRecordingSupportUI();
                    processRecordedAudio();
                };
                
                if (typeof appState.mediaRecorder.start === 'function') {
                    appState.mediaRecorder.start(100);
                } else {
                    appState.mediaRecorder.start();
                }
                
                const startButton = document.getElementById('start-recording-btn');
                const stopButton = document.getElementById('stop-recording-btn');
                if (startButton) {
                    startButton.style.display = 'none';
                }
                if (stopButton) {
                    stopButton.style.display = 'inline-block';
                }
                document.getElementById('mic-warning').style.display = 'none';
                
                if (appState.micLevelUpdate) {
                    appState.micLevelUpdate();
                }
                
            } catch (error) {
                appState.isRecording = false;
                console.error('Error starting recording:', error);
                const startButton = document.getElementById('start-recording-btn');
                const stopButton = document.getElementById('stop-recording-btn');
                if (startButton) {
                    startButton.style.display = 'inline-block';
                }
                if (stopButton) {
                    stopButton.style.display = 'none';
                }
                showRecordingAlert('Recording is unavailable. Please verify microphone access or upload an audio file instead.', 'warning');
                updateRecordingSupportUI();
            }
        }

        function stopRecording(auto = false) {
            if (appState.mediaRecorder && appState.isRecording) {
                appState.mediaRecorder.stop();
                appState.isRecording = false;

                // Update UI
                document.getElementById('start-recording-btn').style.display = 'inline-block';
                document.getElementById('stop-recording-btn').style.display = 'none';

                // Reset mic level
                const micLevel = document.getElementById('mic-level');
                micLevel.style.width = '0%';

                if (auto) {
                    let message = '';
                    let tone = 'info';

                    switch (appState.autoStopReason) {
                        case 'silence':
                            message = 'üîá Recording stopped automatically after 5 seconds of silence. Processing your response...';
                            break;
                        case 'noise':
                            message = 'üì¢ Recording stopped automatically after 5 seconds of noise. Processing your response...';
                            break;
                        case 'skip':
                            message = 'Recording cancelled for this question.';
                            tone = 'warning';
                            break;
                        default:
                            message = '';
                    }

                    if (message) {
                        showRecordingAlert(message, tone);
                    }
                }
            }
        }

        async function processRecordedAudio() {
            if (!appState.recordedBlob) return;
            
            try {
                // If recording was skipped, don't process the audio
                if (appState.autoStopReason === 'skip') {
                    appState.autoStopReason = null;
                    return;
                }
                
                // Reset auto-stop reason but continue processing the audio
                appState.autoStopReason = null;

                const formData = new FormData();
                const extension = appState.recordingExtension || mimeTypeToExtension(appState.recordedBlob.type);
                const safeExtension = extension || 'webm';
                formData.append('audio', appState.recordedBlob, `recording.${safeExtension}`);
                
                // Include session info to store transcript persistently
                if (appState.sessionId) {
                    formData.append('session_id', appState.sessionId);
                    formData.append('question_index', appState.currentQuestionIndex);
                }
                
                const response = await fetch(`${API_BASE}/transcribe`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    const transcription = result.transcript ?? result.transcription ?? '';

                    if (!transcription) {
                        throw new Error('No transcription returned from server');
                    }
                    
                    document.getElementById('transcription-text').textContent = transcription;
                    document.getElementById('transcription-display').style.display = 'block';
                    hideRecordingAlert();
                    
                    appState.pendingResponse = {
                        question: appState.approvedQuestions[appState.currentQuestionIndex],
                        transcription,
                        timestamp: new Date().toISOString(),
                        recordedBlob: appState.recordedBlob,  // Preserve the recorded audio blob
                        transcript_id: result.transcript_id  // Store the transcript ID from server
                    };
                    
                    const postActions = document.getElementById('post-response-actions');
                    const nextButton = document.getElementById('next-question-btn');
                    const redoButton = document.getElementById('redo-question-btn');
                    const startButton = document.getElementById('start-recording-btn');
                    
                    if (postActions) {
                        postActions.classList.remove('hidden');
                    }
                    if (nextButton) {
                        nextButton.disabled = false;
                        nextButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                    if (redoButton) {
                        redoButton.disabled = false;
                    }
                    if (startButton) {
                        startButton.disabled = true;
                    }
                    
                } else {
                    throw new Error(result.detail || 'Transcription failed');
                }
                
            } catch (error) {
                console.error("Error during audio processing:", error);
                const errorMessage = error.message || JSON.stringify(error);
                alert('Error processing audio: ' + errorMessage + '. See console for details.');
            } finally {
                appState.recordedBlob = null;
                appState.audioChunks = [];
            }
        }

        async function handleAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const formData = new FormData();
                formData.append('audio', file);
                
                // Include session info to store transcript persistently
                if (appState.sessionId) {
                    formData.append('session_id', appState.sessionId);
                    formData.append('question_index', appState.currentQuestionIndex);
                }
                
                const response = await fetch(`${API_BASE}/transcribe`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    const transcription = result.transcript ?? result.transcription ?? '';

                    if (!transcription) {
                        throw new Error('No transcription returned from server');
                    }
                    
                    document.getElementById('transcription-text').textContent = transcription;
                    document.getElementById('transcription-display').style.display = 'block';
                    hideRecordingAlert();
                    
                    appState.pendingResponse = {
                        question: appState.approvedQuestions[appState.currentQuestionIndex],
                        transcription,
                        timestamp: new Date().toISOString(),
                        uploadedFileName: file.name,
                        recordedBlob: file,  // Store the uploaded file for server submission
                        transcript_id: result.transcript_id  // Store the transcript ID from server
                    };
                    
                    const postActions = document.getElementById('post-response-actions');
                    const nextButton = document.getElementById('next-question-btn');
                    const redoButton = document.getElementById('redo-question-btn');
                    const startButton = document.getElementById('start-recording-btn');
                    
                    if (postActions) {
                        postActions.classList.remove('hidden');
                    }
                    if (nextButton) {
                        nextButton.disabled = false;
                        nextButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                    if (redoButton) {
                        redoButton.disabled = false;
                    }
                    if (startButton) {
                        startButton.disabled = true;
                    }
                    
                } else {
                    throw new Error(result.detail || 'Transcription failed');
                }
                
            } catch (error) {
                console.error("Error during uploaded audio processing:", error);
                const errorMessage = error.message || JSON.stringify(error);
                alert('Error processing uploaded audio: ' + errorMessage + '. See console for details.');
            }
        }

        async function continueToNextQuestion() {
            if (!appState.pendingResponse) {
                showRecordingAlert('Please record or upload a response before continuing.', 'warning');
                return;
            }

            // Submit response to server
            try {
                await submitResponseToServer(appState.pendingResponse);
                appState.responses.push(appState.pendingResponse);
                appState.pendingResponse = null;
            } catch (error) {
                console.error('Failed to submit response:', error);
                showRecordingAlert(`Failed to submit response: ${error.message}`, 'error');
                return;
            }

            const postActions = document.getElementById('post-response-actions');
            if (postActions) {
                postActions.classList.add('hidden');
            }
            const startButton = document.getElementById('start-recording-btn');
            if (startButton) {
                startButton.disabled = false;
            }
            const nextButton = document.getElementById('next-question-btn');
            if (nextButton) {
                nextButton.disabled = true;
                nextButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
            const audioUpload = document.getElementById('audio-upload');
            if (audioUpload) {
                audioUpload.value = '';
            }
            hideRecordingAlert();

            appState.currentQuestionIndex++;
            displayCurrentQuestion();
        }

        function redoCurrentQuestion() {
            appState.pendingResponse = null;
            hideRecordingAlert();

            const postActions = document.getElementById('post-response-actions');
            if (postActions) {
                postActions.classList.add('hidden');
            }
            const startButton = document.getElementById('start-recording-btn');
            if (startButton) {
                startButton.disabled = false;
            }
            const nextButton = document.getElementById('next-question-btn');
            if (nextButton) {
                nextButton.disabled = true;
                nextButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
            const audioUpload = document.getElementById('audio-upload');
            if (audioUpload) {
                audioUpload.value = '';
            }

            document.getElementById('transcription-text').textContent = '';
            document.getElementById('transcription-display').style.display = 'none';
        }

        async function skipQuestion() {
            if (appState.isRecording) {
                appState.autoStopReason = 'skip';
                stopRecording(true);
            }

            stopQuestionAudio();
            hideRecordingAlert();
            appState.pendingResponse = null;

            const postActions = document.getElementById('post-response-actions');
            if (postActions) {
                postActions.classList.add('hidden');
            }
            const startButton = document.getElementById('start-recording-btn');
            if (startButton) {
                startButton.disabled = false;
            }
            const nextButton = document.getElementById('next-question-btn');
            if (nextButton) {
                nextButton.disabled = true;
                nextButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
            const audioUpload = document.getElementById('audio-upload');
            if (audioUpload) {
                audioUpload.value = '';
            }
            document.getElementById('transcription-text').textContent = '';
            document.getElementById('transcription-display').style.display = 'none';

            // Save empty response and submit to server
            const skipResponse = {
                question: appState.approvedQuestions[appState.currentQuestionIndex],
                transcription: '(Question skipped)',
                timestamp: new Date().toISOString(),
                skipped: true
            };
            
            try {
                await submitSkipToServer();
                appState.responses.push(skipResponse);
            } catch (error) {
                console.error('Failed to submit skip:', error);
                showRecordingAlert(`Failed to submit skip: ${error.message}`, 'error');
                return;
            }
            
            // Move to next question
            appState.currentQuestionIndex++;
            displayCurrentQuestion();
        }

        // Interview Completion
        function completeInterview() {
            // Hide interview section, show completion section
            document.getElementById('interview-section').style.display = 'none';
            document.getElementById('completion-section').style.display = 'block';
            
            appState.currentScreen = 'completed';
            // Add a small delay to ensure server has updated the interview status
            setTimeout(() => displayInterviewResults(), 500);
            
            // Stop any ongoing audio
            stopQuestionAudio(false);
            
            // Stop mic stream
            if (appState.micStream) {
                appState.micStream.getTracks().forEach(track => track.stop());
                appState.micStream = null;
            }
        }

        // Helper function to submit response to server
        async function submitResponseToServer(responseData) {
            if (!appState.sessionId) {
                throw new Error('No active session');
            }
            
            const formData = new FormData();
            formData.append('session_id', appState.sessionId);
            formData.append('question_index', appState.currentQuestionIndex);
            
            // Include transcript_id if available (transcript already stored)
            if (responseData.transcript_id) {
                formData.append('transcript_id', responseData.transcript_id);
            }
            
            const response = await fetch(`${API_BASE}/interview/submit`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server responded with ${response.status}: ${errorText}`);
            }
            
            return await response.json();
        }
        
        // Helper function to submit skip to server
        async function submitSkipToServer() {
            if (!appState.sessionId) {
                throw new Error('No active session');
            }
            
            const formData = new FormData();
            formData.append('session_id', appState.sessionId);
            formData.append('question_index', appState.currentQuestionIndex);
            // Note: no transcript_id means it will be handled as a skip
            
            const response = await fetch(`${API_BASE}/interview/submit`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server responded with ${response.status}: ${errorText}`);
            }
            
            return await response.json();
        }

        async function displayInterviewResults(retryCount = 0) {
            const resultsContainer = document.getElementById('interview-results');
            resultsContainer.innerHTML = '<div class="flex justify-center items-center py-8"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div><span class="ml-3 text-gray-600">Analyzing responses and calculating scores...</span></div>';
            
            try {
                // Fetch detailed results with AI scoring from the backend
                const response = await fetch(`${API_BASE}/interview/${appState.sessionId}/results`);
                
                if (!response.ok) {
                    // Try to get detailed error message from server
                    let errorDetail = '';
                    try {
                        const result = await response.json();
                        errorDetail = result.detail || '';
                    } catch (e) {
                        errorDetail = response.statusText;
                    }
                    
                    // If interview not yet completed and we haven't retried too many times
                    if (response.status === 400 && retryCount < 3) {
                        console.log(`Interview not ready yet (${errorDetail}), retrying in ${(retryCount + 1) * 1000}ms...`);
                        setTimeout(() => displayInterviewResults(retryCount + 1), (retryCount + 1) * 1000);
                        return;
                    }
                    throw new Error(`Failed to fetch interview results: ${response.status} - ${errorDetail}`);
                }
                
                const results = await response.json();
                resultsContainer.innerHTML = '';
                
                // Display overall score summary
                const summaryDiv = document.createElement('div');
                summaryDiv.className = 'bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-xl border border-blue-200 mb-6';
                summaryDiv.innerHTML = `
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-xl font-bold text-gray-900">Interview Summary</h3>
                        <div class="text-right">
                            <div class="text-3xl font-bold text-blue-600">${results.average_score.toFixed(1)}/10</div>
                            <div class="text-sm text-gray-600">Overall Score</div>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                        <div class="bg-white p-3 rounded-lg">
                            <div class="text-2xl font-semibold text-gray-900">${results.total_questions}</div>
                            <div class="text-sm text-gray-600">Questions Asked</div>
                        </div>
                        <div class="bg-white p-3 rounded-lg">
                            <div class="text-2xl font-semibold text-gray-900">${results.completed_responses}</div>
                            <div class="text-sm text-gray-600">Responses Given</div>
                        </div>
                        <div class="bg-white p-3 rounded-lg">
                            <div class="text-2xl font-semibold text-gray-900">${Math.round((results.completed_responses / results.total_questions) * 100)}%</div>
                            <div class="text-sm text-gray-600">Completion Rate</div>
                        </div>
                    </div>
                `;
                resultsContainer.appendChild(summaryDiv);
                
                // Display individual question results with AI scoring
                results.responses.forEach((response, index) => {
                    const scoreColor = response.score >= 8 ? 'green' : response.score >= 6 ? 'yellow' : response.score >= 4 ? 'orange' : 'red';
                    const scoreColorClass = response.score >= 8 ? 'text-green-600 bg-green-50 border-green-200' : 
                                          response.score >= 6 ? 'text-yellow-600 bg-yellow-50 border-yellow-200' : 
                                          response.score >= 4 ? 'text-orange-600 bg-orange-50 border-orange-200' : 
                                          'text-red-600 bg-red-50 border-red-200';
                    
                    const responseDiv = document.createElement('div');
                    responseDiv.className = 'bg-white p-6 rounded-xl border border-gray-200 shadow-sm hover:shadow-md transition-shadow';
                    responseDiv.innerHTML = `
                        <div class="flex justify-between items-start mb-4">
                            <div class="flex-1">
                                <h4 class="font-semibold text-lg text-gray-900 mb-2">Question ${index + 1}</h4>
                                <p class="text-gray-700 mb-4">${response.question}</p>
                            </div>
                            <div class="ml-4 text-center">
                                <div class="text-2xl font-bold ${scoreColorClass} px-3 py-1 rounded-lg border">${response.score}/10</div>
                                <div class="text-xs text-gray-500 mt-1">AI Score</div>
                            </div>
                        </div>
                        
                        <div class="space-y-4">
                            <div class="bg-gray-50 p-4 rounded-lg border-l-4 border-blue-500">
                                <div class="text-sm font-medium text-gray-600 mb-2">Your Response:</div>
                                <p class="text-gray-900">${response.transcript}</p>
                            </div>
                            
                            <div class="bg-blue-50 p-4 rounded-lg border-l-4 border-blue-400">
                                <div class="text-sm font-medium text-blue-800 mb-2">AI Feedback:</div>
                                <p class="text-blue-900">${response.feedback}</p>
                            </div>
                            
                            <div class="grid md:grid-cols-2 gap-4">
                                <div class="bg-green-50 p-4 rounded-lg border-l-4 border-green-400">
                                    <div class="text-sm font-medium text-green-800 mb-2">‚úÖ Strengths:</div>
                                    <p class="text-green-900">${response.strengths}</p>
                                </div>
                                
                                <div class="bg-orange-50 p-4 rounded-lg border-l-4 border-orange-400">
                                    <div class="text-sm font-medium text-orange-800 mb-2">üéØ Areas for Improvement:</div>
                                    <p class="text-orange-900">${response.areas_for_improvement}</p>
                                </div>
                            </div>
                        </div>
                    `;
                    resultsContainer.appendChild(responseDiv);
                });
                
            } catch (error) {
                console.error('Error fetching detailed results:', error);
                resultsContainer.innerHTML = '';
                
                // Fallback to basic display if detailed results fail
                appState.responses.forEach((response, index) => {
                    const responseDiv = document.createElement('div');
                    responseDiv.className = 'bg-gray-50 p-4 rounded-lg border border-gray-200';
                    responseDiv.innerHTML = `
                        <div class="font-semibold text-gray-900 mb-2">Question ${index + 1}</div>
                        <div class="text-gray-700 mb-3">${response.question}</div>
                        <div class="bg-white p-3 rounded border-l-4 border-blue-500">
                            <div class="text-sm text-gray-600 mb-1">Your Response:</div>
                            <div class="text-gray-900">${response.transcription}</div>
                        </div>
                        <div class="mt-3 text-sm text-orange-600">
                            ‚ö†Ô∏è Detailed AI scoring unavailable. Please try again or check server connection.
                        </div>
                    `;
                    resultsContainer.appendChild(responseDiv);
                });
            }
        }

        function startNewInterview() {
            console.log("Starting new interview: stopping media tracks and resetting state.");

            // Stop any existing media streams to release the microphone
            if (appState.micStream) {
                appState.micStream.getTracks().forEach(track => track.stop());
                console.log("Microphone stream stopped.");
            }

            // Close the audio context to release audio processing resources
            if (appState.audioContext && appState.audioContext.state !== 'closed') {
                appState.audioContext.close();
                console.log("AudioContext closed.");
            }
            
            // Reloading the page is the most robust way to ensure a completely clean state
            // for all browser media APIs and to avoid complex state management bugs.
            window.location.reload();
        }

        function downloadResults() {
            const resultsJSON = JSON.stringify({
                sessionId: appState.sessionId,
                timestamp: new Date().toISOString(),
                questions: appState.approvedQuestions,
                responses: appState.responses
            }, null, 2);
            const blob = new Blob([resultsJSON], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `interview_results_${appState.sessionId}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</body>

</html>
